<!DOCTYPE html>
<html lang="en">
<head>
	    
        <title>Flask Web Development</title>
        <meta charset="utf-8"/>
        <meta name="description"
              content="a blog from a scrach."/>
        <link rel="stylesheet" href="http://localhost:8000/theme/css/main.css"/>

        <link rel="stylesheet" href="http://localhost:8000/theme/css/pygments/default.css"/>



	<link rel="stylesheet" href="http://localhost:8000/theme/css/article.css"/>
</head>

<body>

<div id="banner">
    <div class="banner_container">

        <ul class="banner_list">
            <li><a href="http://localhost:8000" style="font-weight:400"><strong>White Blog</strong></a></li>
            <li><a href="http://localhost:8000">home</a></li>
            <li><a href="http://localhost:8000/category/dev.html">dev</a></li>
            <li><a href="http://localhost:8000/category/fq.html">FQ</a></li>
            <li><a href="http://localhost:8000/pages/about-me.html">about</a></li>
        </ul>

        <div class="rss_symbol" style="background-image:url('http://localhost:8000/theme/images/rss-symbol.svg')">
            <a href="#"></a>
        </div>

    </div>
</div>

	<section id="content">
		<article>
			<header>
				<h1 class="entry-title"><a href="http://localhost:8000/flask-web-development.html" rel="bookmark" title="Permalink to <Flask Web Development>">Flask Web Development</a></h1>
				<p class="entry-date">2014-12-03</p>
			</header>

			<div class="entry-content">
				<p>数据存储方面，用到的是 redis 而不是关系型数据库。redis 是一种内存（in-memory）数据库，仅支持 Unix 系统，但有非官方的 Windows 端。</p>
<h2>Dependences</h2>
<p>Flask 的主要两大依赖
1. Werkzeug，WSGI 工具库；
2. Jinja2，模版</p>
<p>数据存储方面，用到的是 redis 而不是关系型数据库。redis 是一种内存（in-memory）数据库，仅支持 Unix 系统，但有非官方的 Windows 端。</p>
<h2>Chapter 2. Basic Application Structure</h2>
<p>最简单的 Flask 应用：</p>
<div class="highlight"><pre><span></span><span class="c1"># hello.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="c1"># create Flask instance</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span> 

<span class="c1"># a: route URL to function</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;h1&gt;Hello My App&lt;/h1&gt;&#39;</span>

<span class="c1"># b: dynamic route</span>
<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;&lt;h1&gt;hello, </span><span class="si">%s</span><span class="s1">!&lt;/h1&gt;&#39;</span> <span class="o">%</span> <span class="n">name</span>

<span class="c1"># c: start server</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>目录结构：
- Project Directory
    - templates -> Jinja2 files
    - static -> images, JS, CSS</p>
<h3>Routes and View Functions</h3>
<p>客户端向服务器发送一个请求，Flask app 的实例接受这个请求，对于这个应用实例，它需要知道对于每一条 URL 请求执行什么操作，所以它有一套 URL 对应到 Python 函数的匹配规则。这种对 URL 和函数之间的联系的处理就叫 <strong>route</strong>。</p>
<p>最简单的定义一个 route 的方式是用 <code>Flask</code> 实例提供的装饰器 <code>route</code> 来修饰函数。如注释 <code>a</code>，这样就把 <code>index()</code> 函数注册为应用根目录下的 handler。比如域名是 <em>www.abc.com</em>，则访问 <em>http://www.abc.com</em> 时就会触发这个 <code>index()</code> 函数，客户端收到的 response 即是其返回值。</p>
<p>但是这样将响应（HTML 字符串）嵌入到 Python 代码里面非常不利于维护，第三章会介绍更合适的生成响应的方式。</p>
<p>类似 <code>index()</code> 这样的函数被称为视图函数（<strong>view function</strong>）。</p>
<p>使用动态元素（<strong>dynamic component</strong>）可以动态地 route URL（注释 <code>b</code>）。Flask 支持的 route 类型有 <code>string</code> <code>int</code> <code>float</code> 和 <code>path</code>。<code>path</code> 与 <code>string</code> 的区别是前者不会把 <code>/</code> 作为分隔符。
示例：<code>/user/&lt;int:id&gt;</code></p>
<h3>运行</h3>
<p>用 <code>Flask</code> 实例的 <code>app()</code> 方法来启动服务器（注释 <code>c</code>）。然后执行 Python 程序。
<img alt="screenshot" src="/images/flask-web-development/1.jpeg"> 
<img alt="screenshot" src="/images/flask-web-development/2.jpeg"></p>
<h3>请求、响应周期</h3>
<h4>a. (Application and Request) Contexts</h4>
<p>Flask 有两种场景（<strong>context</strong>），四个全局场景变量（<strong>context variables</strong>）：
<img alt="screenshot" src="/images/flask-web-development/3.jpeg"></p>
<p>在派发一个请求前，Flask 会激活（activates/pushes）两种 contexts，当请求处理完毕时移除。</p>
<p>如上表所示，当 application context 被激活，变量 <code>current_app</code> 和 <code>g</code> 会在线程中可用；request context 激活时同理。如果 context 没有被激活时就访问到变量，会生成错误。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">app</span> <span class="c1"># Flask instance</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">current_app</span> <span class="c1"># context variable</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">current_app</span><span class="o">.</span><span class="n">name</span> 
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="o">...</span>
<span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">working</span> <span class="n">outside</span> <span class="n">of</span> <span class="n">application</span> <span class="n">context</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">app_ctx</span> <span class="o">=</span> <span class="n">app</span><span class="o">.</span><span class="n">app_context</span><span class="p">()</span> <span class="c1"># obtain application context</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">app_ctx</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">current_app</span><span class="o">.</span><span class="n">name</span> 
<span class="s1">&#39;hello&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">app_ctx</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</pre></div>


<h4>b. Request Dispatching</h4>
<p>用 <code>Flask</code> 的 <code>url_map</code> 属性可以查看实例中已有的 route map。</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="err">$</span> <span class="n">python3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">app</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">app</span><span class="o">.</span><span class="n">url_map</span> 
<span class="n">Map</span><span class="p">([</span><span class="o">&lt;</span><span class="n">Rule</span> <span class="s1">&#39;/&#39;</span> <span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">OPTIONS</span><span class="p">,</span> <span class="n">GET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">index</span><span class="o">&gt;</span><span class="p">,</span> 
 <span class="o">&lt;</span><span class="n">Rule</span> <span class="s1">&#39;/static/&lt;filename&gt;&#39;</span> <span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">OPTIONS</span><span class="p">,</span> <span class="n">GET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">static</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="o">&lt;</span><span class="n">Rule</span> <span class="s1">&#39;/user/&lt;name&gt;&#39;</span> <span class="p">(</span><span class="n">HEAD</span><span class="p">,</span> <span class="n">OPTIONS</span><span class="p">,</span> <span class="n">GET</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">&gt;</span><span class="p">])</span>
</pre></div>


<p>注意到这里第二个 rule 不是我们用 <code>app.route</code> 装饰器定义的，这是 Flask 特供的用于访问静态资源的 route，关于静态文件会在第三章提到。</p>
<p><code>(HEAD, OPTIONS, GET)</code> 代表的是请求方法（<strong>request method</strong>），Flask 为 route 附上请求方法，这样能实现对于访问同一个 URL 的不同请求，调用不同的 view function。关于区别不同的请求方法会在第四章提及。</p>
<h4>c. Request Hooks</h4>
<p>钩子函数，定义请求派发的前后执行的函数，类似 Java Web 中的过滤器，后面还会提及。</p>
<h4>d. Response</h4>
<p>上面的 view function 中我们返回的响应是简单的 HTML 字符串，但我们还可以返回一个 <code>Response</code> 对象。可以用 <code>make_response()</code> 这个静态方法生成，用它还可以进行 cookie 设置等操作。</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">make_response</span> 

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> 
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="s1">&#39;&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;&#39;</span><span class="p">)</span> 
    <span class="n">response</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">&#39;answer&#39;</span><span class="p">,</span> <span class="s1">&#39;42&#39;</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">response</span>
</pre></div>


<p>如果要进行重定向，常用 <code>redirect(another_url_path)</code>，它也返回一个 <code>Response</code> 对象。</p>
<p>如果要进行错误处理，<code>abort(404)</code> 能返回 404 状态码。不过要注意的是它不会把控制交还给调用它的函数，而是交还 web 服务器抛出异常。</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">abort</span> 

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;id&gt;&#39;</span><span class="p">)</span> 
<span class="k">def</span> <span class="nf">get_user</span><span class="p">(</span><span class="nb">id</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">load_user</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">user</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span> 
    <span class="k">return</span> <span class="s1">&#39;&lt;h1&gt;Hello, </span><span class="si">%s</span><span class="s1">&lt;/h1&gt;&#39;</span> <span class="o">%</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span>
</pre></div>


<h3>Flask 扩展</h3>
<p>如果我们要对 Flask 服务器进行配置，可以在 <code>app.run()</code> 中添加参数，但更方便的方式是通过命令行传参。</p>
<p>先安装 <code>flask-script</code>：</p>
<div class="highlight"><pre><span></span>(venv) $ pip install flask-script
</pre></div>


<p>用 <code>Manager</code> 类接管 Flask app：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask.ext.script</span> <span class="kn">import</span> <span class="n">Manager</span> 
<span class="n">manager</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>

<span class="c1"># ...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>


<p>这时候再运行程序，就会提示提供参数了：</p>
<div class="highlight"><pre><span></span>(env) $ python3 hello.py
usage: hello.py [-?] {shell,runserver} ...

positional arguments:
  {shell,runserver}
    shell            Runs a Python shell inside Flask application context.
    runserver        Runs the Flask development server i.e. app.run()

optional arguments:
  -?, --help         show this help message and exit
</pre></div>


<p>安装提示，比如要启动服务器：</p>
<div class="highlight"><pre><span></span>(env) $ python3 hello.py runserver
</pre></div>


<p>配置 host（a.b.c.d:5000）使服务器在局域网络中可访问：</p>
<div class="highlight"><pre><span></span>(env) $ python hello.py runserver --host 0.0.0.0 
</pre></div>


<h2>Chapter 3. Templates</h2>
<p>从第二章了解到，view function 的任务是针对请求生成响应，这对简单的请求没问题，但如果稍微复杂一点就会发现矛盾。比如用户发起一个注册请求，view function 需要 1) 访问数据库创建新记录 2) 生成响应发送给客户端。这样就把业务逻辑（<strong>business logic</strong>）和展示逻辑（<strong>presentation logic</strong>）混淆在了一起，导致代码难以理解且不利于维护。</p>
<p>把展示层逻辑转移到模版（<strong>template</strong>）即可以提高可维护性。模版是包含响应文本的 HTML 文件，数据由占位符变量表示。而把变量替换为真实的数据的过程就叫做渲染（<strong>rendering</strong>）。</p>
<h3>Jinja2 模版渲染引擎</h3>
<p>Jinja2 模版语法和变量的使用</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">render_template</span> <span class="c1"># import rendering method</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;index.html&#39;</span><span class="p">)</span> <span class="c1"># refer to templates/index.html</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">user</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;user.html&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="c1"># dynamic component</span>
</pre></div>


<p>在模版文件中使用构造器 <code>{{ variable }}</code> 来获得变量：</p>
<div class="highlight"><pre><span></span><span class="c">&lt;!-- templates/user.html --&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello, {{ name }}!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</pre></div>


<h4>Jinja2 variable filters</h4>
<p>Jinja2 提供了一些实用的变量过滤器，查阅<a href="http://jinja.pocoo.org/docs/2.10/templates/">官方文档</a>获取更多用法。
<img alt="screenshot" src="/images/flask-web-development/4.jpeg">
例如，Jinja2 默认会对变量进行转义，如果需要传递 HTML 代码，用 <code>safe</code> 来避免转义：<code>{{ variable_name|safe }}</code>。但要注意，永远不要对不可信变量使用 <code>safe</code> 过滤（比如用户提交的表单）。</p>
<h4>Control Structures</h4>
<p>条件判断：</p>
<div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">if</span> <span class="nv">user</span> <span class="cp">%}</span><span class="x"> </span>
<span class="x">    Hello, </span><span class="cp">{{</span> <span class="nv">user</span> <span class="cp">}}</span><span class="x">! </span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">    Hello, Stranger! </span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>


<p>循环语句：</p>
<div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">for</span> <span class="nv">comment</span> <span class="k">in</span> <span class="nv">comments</span> <span class="cp">%}</span><span class="x"></span>
<span class="x">    </span><span class="cp">{{</span> <span class="nv">comment</span> <span class="cp">}}</span><span class="x"></span>
<span class="cp">{%</span> <span class="k">endfor</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>


<p>宏（macro），类似 Python 中的函数：</p>
<div class="highlight"><pre><span></span>{% macro render_comment(comment) %} 
    <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>{{ comment }}<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span> 
{% endmacro %}

<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
    {% for comment in comments %} 
        {{ render_comment(comment) }} 
    {% endfor %} 
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre></div>


<p>为了提高 macros 的可用性，可以放到一个单独的 html 文件中，在模版通过 <code>import</code> 导入：</p>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="o">%</span> <span class="kn">import</span> <span class="s1">&#39;macros.html&#39;</span> <span class="k">as</span> <span class="n">macros</span> <span class="o">%</span><span class="p">}</span> 
<span class="p">{{</span> <span class="n">macros</span><span class="o">.</span><span class="n">render_comment</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="p">}}</span> 
</pre></div>


<p>重复使用的模版代码也可以单独拿出来，在需要的时候导入：</p>
<div class="highlight"><pre><span></span>{% include &#39;common.html&#39; %}
</pre></div>


<p>更进一步，可以用模版继承来完善代码结构。首先创建一个基本模版：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span> 
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    {% block head %}
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>{% block title %}{% endblock %} - My Application<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    {% endblock %} 
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span> 
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    {% block body %}
    {% endblock %} 
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span> 
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>


<p>实现继承的模版：</p>
<div class="highlight"><pre><span></span>{% extends &quot;base.html&quot; %} 
{% block title %}Index{% endblock %} 
{% block head %}
    <span class="c">&lt;!-- 如果被继承的 block 中包换元素，用 super() 获取 --&gt;</span>
    {{ super() }} 
    <span class="p">&lt;</span><span class="nt">style</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">style</span><span class="p">&gt;</span> 
{% endblock %} 
{% block body %} 
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello, World!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span> 
{% endblock %}
</pre></div>


<p><strong>由于修饰笔记耗费太多的时间，为了加快进度，从这里开始往后改变以笔记为首的学习方式，多做引用和直接在原书上批注（这样的话可能以后随时按需拓展）</strong></p>
<h3>Twitter Bootstrap Integration with Flask Bootstrap</h3>
<p>Bootstrap 是 Twitter 的开源框架，它提供创建网页的用户界面接口，兼容性好。简单的说就是一个 CSS 和 JS 库。</p>
<p>使用 Bootstrap 有多种方式，可以将编译过的 CSS 和 JS 文件下载下来放到项目中、用包管理器安装、或者用 Bootstrap 官方提供的免费 CDN（通过 HTML <code>&lt;link&gt;</code>）。在这里，我们使用第二种方式。</p>
<p>如何加载 Bootstrap：
1. 通过虚拟环境安装包</p>
<div class="highlight"><pre><span></span>(env) $ pip install flask-bootstrap
</pre></div>


<ol>
<li>在 Python 程序中导入 <code>Bootstrap</code> 模块</li>
<li>用 Flask 应用作为构造器参数实例化 <code>Bootstrap</code>（变量名称不重要）</li>
</ol>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask_bootstrap</span> <span class="kn">import</span> <span class="n">Bootstrap</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">instance</span> <span class="o">=</span> <span class="n">Bootstrap</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>


<ol>
<li>通过 Jinja2 导入</li>
</ol>
<div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">extends</span> <span class="s2">&quot;bootstrap/base.html&quot;</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>


<p>Bootstrap 本身是在 base template 的 <code>styles</code> 和 <code>scripts</code> block 里面定义的，所以如果要继承这两个 block，一定要加上 <code>{{ super() }}</code>。</p>
<p>可供使用的 blocks 参考：<a href="https://pythonhosted.org/Flask-Bootstrap/basic-usage.html">https://pythonhosted.org/Flask-Bootstrap/basic-usage.html</a></p>
<h3>链接处理</h3>
<p>Flask 提供了一个 <code>url_for()</code> 方法。几种用法举例：
1. 为 URL 填入动态元素
<code>url_for('user', name='john')</code> -> <em>/user/john.</em>
2. 设置请求参数字符串
<code>url_for('index', page=2)</code> -> <em>/?page=2</em>
3. 指定为外部链接
<code>url_for('index', _external=True)</code> -> <em>http://localhost:5000</em>
4. 链接到 static 目录下的 CSS 文件
<code>url_for('static', filename='css/styles.css')</code> -> <em>/static/css/styles.css</em></p>
<p>下面是用 Jinja2 导入一些头部文件的示例：</p>
<div class="highlight"><pre><span></span><span class="cp">{%</span> <span class="k">block</span> <span class="nv">head</span> <span class="cp">%}</span><span class="x"> </span>
<span class="cp">{{</span> <span class="nb">super</span><span class="o">()</span> <span class="cp">}}</span><span class="x"> &lt;!—- 注意要继承 Bootstrap 中的 head -—&gt;</span>
<span class="x">&lt;link rel=&quot;shortcut icon&quot; href=&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;static&#39;</span><span class="o">,</span> <span class="nv">filename</span> <span class="o">=</span> <span class="s1">&#39;favicon.ico&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="x">&quot; type=&quot;image/x-icon&quot;&gt; </span>
<span class="x">&lt;link rel=&quot;icon&quot; href=&quot;</span><span class="cp">{{</span> <span class="nv">url_for</span><span class="o">(</span><span class="s1">&#39;static&#39;</span><span class="o">,</span> <span class="nv">filename</span> <span class="o">=</span> <span class="s1">&#39;favicon.ico&#39;</span><span class="o">)</span> <span class="cp">}}</span><span class="x">&quot; type=&quot;image/x-icon&quot;&gt; </span>
<span class="cp">{%</span> <span class="k">endblock</span> <span class="cp">%}</span><span class="x"></span>
</pre></div>


<h3>用 Flask-Moment 实现时区的本地化</h3>
<p>为了统一标准，服务器时间都使用 UTC 标准时间，时区现实的本地化在客户端浏览器完成。moment.js 是一个开源的客户端的 JS 库，Flask 的拓展将它和 Jinja2 模版进行了整合，这就是 Flask-Moment。</p>
<p>安装：</p>
<div class="highlight"><pre><span></span>(env) $ pip install flask-moment
</pre></div>


<p>初始化：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask.ext.moment</span> <span class="kn">import</span> <span class="n">Moment</span> 
<span class="n">moment</span> <span class="o">=</span> <span class="n">Moment</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>


<p>除了 moment.js，Flask-Moment 还依赖于 jquery.js，不过 Bootstrap 已经包含了对前者，所以我们只需要手动导入 moment.js。</p>
<ol>
<li>Import module</li>
</ol>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask_moment</span> <span class="kn">import</span> 
</pre></div>


<ol>
<li>Initialization</li>
</ol>
<div class="highlight"><pre><span></span><span class="n">moment</span> <span class="o">=</span> <span class="n">Moment</span><span class="p">(</span><span class="n">app</span><span class="p">)</span> 
<span class="c1"># `app` refers to Flask instance</span>
<span class="c1"># again, the name in the left is irrelevant.</span>
</pre></div>


<ol>
<li>Pass time object to template</li>
</ol>
<div class="highlight"><pre><span></span><span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;index.html&#39;</span><span class="p">,</span> <span class="n">current_time</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">())</span>
</pre></div>


<ol>
<li>Present local date and time in Jinja2</li>
</ol>
<div class="highlight"><pre><span></span><span class="nt">&lt;p&gt;</span>The local date and time is <span class="cp">{{</span> <span class="nv">moment</span><span class="o">(</span><span class="nv">current_time</span><span class="o">)</span><span class="nv">.format</span><span class="o">(</span><span class="s1">&#39;LLL&#39;</span><span class="o">)</span> <span class="cp">}}</span>.<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;p&gt;</span>That was <span class="cp">{{</span> <span class="nv">moment</span><span class="o">(</span><span class="nv">current_time</span><span class="o">)</span><span class="nv">.fromNow</span><span class="o">(</span><span class="nv">refresh</span><span class="o">=</span><span class="kp">True</span><span class="o">)</span> <span class="cp">}}</span>.<span class="nt">&lt;/p&gt;</span>
<span class="c">{# </span>
<span class="c">The local date and time is September 17, 2018 8:29 PM.</span>
<span class="c">That was a few seconds ago. </span>
<span class="c">*}</span>
</pre></div>


<h2>Chapter 4. Web Forms</h2>
<p>这一章讨论模版与用户的交互。</p>
<p>通过 POST 提交的表单用 <code>request.form</code> 获取</p>
<p><strong>WTForms</strong> 是 Python web 开发中一个灵活的表单验证即渲染库。它与框架无关，可以搭配任何一种 web 框架和模版引擎使用。</p>
<p>安装：</p>
<div class="highlight"><pre><span></span>(env) $ pip install flask-wtf
</pre></div>


<h3>CSRF 保护</h3>
<p>跨站请求伪造（cross-site request forgery, CSRF）是一种恶意的攻击，盗用经过验证的用户身份执行未经授权的命令，如发送邮件、发消息、盗取账号、转账等隐私风险。</p>
<p>什么情况下会发生这种情况呢？比如你在一家安全措施薄弱的银行网站进行了登录操作，然后打开了另一个不安全网站，这个网站就可以利用你的 cookie 中的登录信息，伪造一个由浏览器发出的转账请求。所以 CSRF 利用到的漏洞在于 web 的隐式身份验证机制，WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup>。</p>
<p>要实现 CSRF 保护，Flask-WTF 需要应用配置一个密匙。</p>
<h3>Form Classes</h3>
<p>当使用 Flask-WTF 时，每一个表单都由 <code>Form</code> 的一个子类表示，这个类定义了表单中的元素，每一个都用一个对象表示。可以为每个单独的对象附上一或多个校验器（validator）来确保用户提交的有效内容。</p>
<p>像这样定义一个表单类：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask.ext.wtf</span> <span class="kn">import</span> <span class="n">Form</span> 
<span class="kn">from</span> <span class="nn">wtforms</span> <span class="kn">import</span> <span class="n">StringField</span><span class="p">,</span> <span class="n">SubmitField</span> 
<span class="kn">from</span> <span class="nn">wtforms.validators</span> <span class="kn">import</span> <span class="n">Required</span>

<span class="k">class</span> <span class="nc">NameForm</span><span class="p">(</span><span class="n">Form</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">StringField</span><span class="p">(</span><span class="s1">&#39;What is your name?&#39;</span><span class="p">,</span> <span class="n">validators</span><span class="o">=</span><span class="p">[</span><span class="n">Required</span><span class="p">()])</span> 
    <span class="n">submit</span> <span class="o">=</span> <span class="n">SubmitField</span><span class="p">(</span><span class="s1">&#39;Submit&#39;</span><span class="p">)</span>
</pre></div>


<p>传入构造器的参数，即 <code>Form</code> 基类，是属于 Flask-WTF 扩展下的；而 HTML field 和 validator 是在 WTForms 包中定义的。</p>
<div class="footnote">
<hr>
<ol>
<li id="fn:1">
<p><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a>&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
			</div>
		</article>
	</section>

</body>
</html>